# Instruction Scheduler with UVM Testbench

## 1. Project Overview

This project implements a **SystemVerilog instruction scheduler** and a **UVM-based verification environment**.

### Design goals
- Accept 32-bit instructions from a host
- Decode opcode and dispatch instructions to dedicated output streams
- Support backpressure using ready/valid semantics
- Ensure no instruction loss, duplication, or misrouting
- Keep the design simple, deterministic, and extensible



### Functional Description

The instruction scheduler performs the following steps -

1. Waits for `in_valid` from the host
2. Decodes `instr[31:29]` to determine opcode
3. Routes instruction to the corresponding output stream
4. Applies backpressure if the selected stream is not ready
5. Drops unsupported opcodes (4–7)


A complete **UVM testbench** is provided with -
- One **active host agent**
- Multiple **active receiver agents**
- Ready/valid backpressure handling
- Modular, scalable architecture

### Interface Specification 

#### Host Interface

| Signal     | Direction | Description |
|-----------|----------|-------------|
| `in_valid` | Input    | Host asserts when instruction is valid |
| `in_ready` | Output   | Scheduler ready to accept instruction |
| `in_instr` | Input    | 32-bit instruction |

#### Output Stream Interface (A–D)

| Signal        | Direction | Description |
|--------------|----------|-------------|
| `out_valid_*` | Output   | Output instruction valid |
| `out_ready_*` | Input    | Downstream ready |
| `out_instr_*` | Output   | Instruction payload |


## 2. Instruction Format

| OPCODE[2:0] | Instruction Body |

- Opcode width: **3 bits**
- Total possible opcodes: **8**
- Currently supported output streams: **4 (A–D)**

## 3. RTL Design: `instr_scheduler`

### 3.1 Supported Streams

| Opcode | Output Stream |
|------|---------------|
| 0    | A             |
| 1    | B             |
| 2    | C             |
| 3    | D             |
| 4–7  | Dropped (unsupported) |

---

### 3.2 Interface Summary

#### Host Interface
| Signal     | Direction | Description |
|-----------|----------|-------------|
| `in_valid` | Input    | Host asserts when instruction is valid |
| `in_ready` | Output   | Scheduler ready to accept instruction |
| `in_instr` | Input    | 32-bit instruction |

#### Output Stream Interface (A–D)
| Signal        | Direction | Description |
|--------------|----------|-------------|
| `out_valid_*` | Output   | Instruction valid |
| `out_ready_*` | Input    | Downstream ready |
| `out_instr_*` | Output   | Instruction payload |

---

### 3.3 Ready/Valid Semantics

- **Transfer occurs when**:
- `in_ready`  reflects the readiness of the selected output stream
- `out_valid_*` is a **single-cycle pulse**
- Backpressure propagates cleanly from output stream to host

This design follows **AXI-Stream–style semantics**.

## 4. Verification Plan

### 4.1 Verification Objectives

The verification environment must prove that:

1. Instructions are routed to the correct output stream
2. No instruction is lost or duplicated
3. Backpressure is handled correctly
4. Unsupported opcodes are dropped
5. Protocol timing is correct under all conditions

UVM architecture Description - Insn_Scheduler_Verif_UVM\UVM_Arch.md
---

### 4.2 Verification Methodology

- **Methodology**: UVM (Universal Verification Methodology)
- **Testbench Type**: Constrained-random + directed
- **Checking Style**: Scoreboard-based end-to-end checking
- **Coverage**: Functional opcode coverage

---

### 4.3 Testbench Architecture

#### Agents

| Agent | Type   | Role |
|-----|--------|------|
| Host Agent | Active | Drives instructions |
| Agent A | Active | Receives opcode 0 |
| Agent B | Active | Receives opcode 1 |
| Agent C | Active | Receives opcode 2 |
| Agent D | Active | Receives opcode 3 |

Each agent has:
- Monitor (mandatory)
- Driver (optional for backpressure modeling)

---

### 4.4 Transactions

**Instruction Transaction (`instr_xtn`)**
- `instr` : 32-bit instruction
- `opcode`: extracted from `instr[31:29]`

Transactions are:
- Generated by host sequences
- Observed by monitors
- Compared in the scoreboard

---

### 4.5 Scoreboard Strategy

#### Expected Behavior
- Instructions observed at host input are queued based on opcode
- Receiver outputs are checked against expected queues

#### Error Conditions
- Instruction received on wrong stream
- Instruction received with no expectation
- Instruction mismatch
- Missing instruction

---

### 4.6 Test Scenarios

#### Directed Tests
- Single opcode routing (0, 1, 2, 3)
- Unsupported opcode drop (4–7)
- Reset behavior

#### Random Tests
- Random opcode distribution
- Random instruction payloads
- Mixed valid/ready patterns

#### Stress Tests
- Continuous backpressure on selected stream
- Rapid switching of opcodes
- Long random sequences

---

### 4.7 Coverage Plan

#### Functional Coverage

| Coverage Item | Description |
|--------------|-------------|
| Opcode coverage | All opcodes 0–7 |
| Stream coverage | All outputs A–D |
| Backpressure | Ready deasserted cases |
| Reset | Reset during activity |

Coverage is considered complete when:
- All supported opcodes observed
- Each output stream receives traffic
- Backpressure paths exercised

---

### 4.8 Pass/Fail Criteria

The test suite passes when:
- No `UVM_ERROR` or `UVM_FATAL` is reported
- All functional coverage goals are met
- No scoreboard mismatches occur

---

## 5. Future Scope

Planned or possible enhancements:

- FIFO buffering per opcode
- Support for opcodes 4–7
- Multi-issue instruction dispatch
- Dependency-aware scheduling
- DPI enabled Reference model
- Formal verification (assertions)

---

## 7. Summary and Notes

- Clean RTL with correct ready/valid semantics (sample RTL code)
- Industry-standard UVM architecture
- Scalable, maintainable, and verification-friendly
- Suitable for instruction dispatch pipelines

---
